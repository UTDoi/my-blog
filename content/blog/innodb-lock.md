# ネクストキーロック
- ネクストキーロックはあくまで、あるプライマリインデックスレコードに対するレコードロックとその前にあるギャップへのギャップロックの組み合わせ
- あるプライマリインデックスレコードの次のレコードに対するレコードロックのことを呼ぶのではない
  - まず、innodbでは走査されたインデックスレコードに対してレコードロックがかかる
  - range 検索 においては、右端値の次の値まで走査がかかるので、実際にヒットしたレコードの次のレコードまでネクストキーロックがかかる
    - unique key かつ <= 指定なら次のレコードまで走査する必要は本来ないのだが、実装の複雑化を避けるためそうなっているに違いない！
  - これをネクストキーロックと呼ぶ人も多い

# repeatable read におけるDML別ロック種別
- SELECT
  - lockはなし trx単位でのMVCC
- lock in share mode
  - 共有ネクストキーロック
- update/delete/select for update
  - 排他ネクストキーロック

ただしここでネクストキーロックと言っているのは、where句で実際に走査されたタイプによって異なる
  - 例えば空振りなしの等価検索なら、合致したレコードのみのレコードロックがかかる
  - 空振りありの等価検索なら、その値の次に存在するレコードの前のギャップロック
  - range検索なら 合致したレコードのネクストキーロック(左端と値が一致しているレコードに関しては、レコードロックのみ)+rangeの右端の次に存在するレコードのネクストキーロック

# 挿入インテンションギャップロック
- insert文の実行時に取得される特殊なギャップロック
  - そもそも、正常系においてinsertは常に存在しないkeyに対して行われるので、取得されるロックは常にギャップロックとなる
    - select for update の空振り等価検索とかと同じ
  - 追加するkeyにunique制約がかかっている場合、ギャップロックとはいえギャップだけではなく自身が追加しようとしているkey値に対するレコードロックも暗黙的にとっている
- 挿入インテンションギャップロック自体は競合しないので、同じギャップへの insert は wait が起きない
  - 一方で、普通の排他ギャップロック(例えば、select for update の空振り等価検索だったり delete のrange絞り込みにおけるネクストキーロックのギャップ分だったり)とは競合する
  - また、追加しようとしているkey値に対するレコードロックに関しては普通に競合する
    - そうしないと unique 制約が守れないしね

# 参考資料
https://dbstudy.info/files/20140907/mysql_lock_r2.pdf
